{"ast":null,"code":"import assert from './assert';\nimport { log2, clamp } from './math-utils';\nimport { MAX_LATITUDE, lngLatToWorld, worldToLngLat } from './web-mercator-utils';\nexport default function fitBounds({\n  width,\n  height,\n  bounds,\n  minExtent = 0,\n  maxZoom = 24,\n  padding = 0,\n  offset = [0, 0]\n}) {\n  const [[west, south], [east, north]] = bounds;\n\n  if (Number.isFinite(padding)) {\n    const p = padding;\n    padding = {\n      top: p,\n      bottom: p,\n      left: p,\n      right: p\n    };\n  } else {\n    assert(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));\n  }\n\n  const nw = lngLatToWorld([west, clamp(north, -MAX_LATITUDE, MAX_LATITUDE)]);\n  const se = lngLatToWorld([east, clamp(south, -MAX_LATITUDE, MAX_LATITUDE)]);\n  const size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];\n  const targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];\n  assert(targetSize[0] > 0 && targetSize[1] > 0);\n  const scaleX = targetSize[0] / size[0];\n  const scaleY = targetSize[1] / size[1];\n  const offsetX = (padding.right - padding.left) / 2 / scaleX;\n  const offsetY = (padding.bottom - padding.top) / 2 / scaleY;\n  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n  const centerLngLat = worldToLngLat(center);\n  const zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));\n  assert(Number.isFinite(zoom));\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom\n  };\n}","map":{"version":3,"sources":["../../src/fit-bounds.js"],"names":["minExtent","maxZoom","padding","offset","Number","p","top","bottom","left","right","assert","nw","lngLatToWorld","clamp","se","size","Math","targetSize","width","height","scaleX","scaleY","offsetX","offsetY","center","centerLngLat","worldToLngLat","zoom","log2","longitude","latitude"],"mappings":"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","sourcesContent":["// @ts-nocheck TODO padding\nimport assert from './assert';\nimport {log2, clamp} from './math-utils';\nimport {MAX_LATITUDE, lngLatToWorld, worldToLngLat} from './web-mercator-utils';\n\n// Returns map settings {latitude, longitude, zoom}\n// that will contain the provided corners within the provided width.\n// Only supports non-perspective mode.\n\nexport default function fitBounds({\n  width,\n  height,\n  bounds,\n  minExtent = 0, // 0.01 would be about 1000 meters (degree is ~110KM)\n  maxZoom = 24, // ~x4,000,000 => About 10 meter extents\n  // options\n  padding = 0,\n  offset = [0, 0]\n}) {\n  const [[west, south], [east, north]] = bounds;\n\n  if (Number.isFinite(padding)) {\n    const p = padding;\n    padding = {\n      top: p,\n      bottom: p,\n      left: p,\n      right: p\n    };\n  } else {\n    // Make sure all the required properties are set\n    assert(\n      Number.isFinite(padding.top) &&\n        Number.isFinite(padding.bottom) &&\n        Number.isFinite(padding.left) &&\n        Number.isFinite(padding.right)\n    );\n  }\n\n  const nw = lngLatToWorld([west, clamp(north, -MAX_LATITUDE, MAX_LATITUDE)]);\n  const se = lngLatToWorld([east, clamp(south, -MAX_LATITUDE, MAX_LATITUDE)]);\n\n  // width/height on the Web Mercator plane\n  const size = [\n    Math.max(Math.abs(se[0] - nw[0]), minExtent),\n    Math.max(Math.abs(se[1] - nw[1]), minExtent)\n  ];\n\n  const targetSize = [\n    width - padding.left - padding.right - Math.abs(offset[0]) * 2,\n    height - padding.top - padding.bottom - Math.abs(offset[1]) * 2\n  ];\n\n  assert(targetSize[0] > 0 && targetSize[1] > 0);\n\n  // scale = screen pixels per unit on the Web Mercator plane\n  const scaleX = targetSize[0] / size[0];\n  const scaleY = targetSize[1] / size[1];\n\n  // Find how much we need to shift the center\n  const offsetX = (padding.right - padding.left) / 2 / scaleX;\n  const offsetY = (padding.bottom - padding.top) / 2 / scaleY;\n\n  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n\n  const centerLngLat = worldToLngLat(center);\n  const zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));\n\n  assert(Number.isFinite(zoom));\n\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom\n  };\n}\n"]},"metadata":{},"sourceType":"module"}